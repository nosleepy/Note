#### 点击事件分发

```java
// 事件分发
public boolean dispatchTouchEvent(MotionEvent event) {
    boolean isConsume = false;
    if (isViewGroup) {
        if (onInterceptTouchEvent(event)) {
            isConsume = onTouchEvent(event);
        } else {
            isConsume = child.dispatchTouchEvent(event);
        }
    } else {
        //isView
        isConsume = onTouchEvent(event);
    }
    return isConsume;
}


// 事件处理
public void handleTouchEvent(MotionEvent event) {
    if (!onTouchEvent(event)) {
        getParent.onTouchEvent(event);
    }
}


// onTouch,onTouchEvent,onClick调用关系
public void consumeEvent(MotionEvent event) {
    if (setOnTouchListener) {
        onTouch();
        if (!onTouch()) {
            onTouchEvent(event);
            if (setOnClickListener) {
                onClick();
            }
        }
    } else {
        onTouchEvent(event);
        if (setOnClickListener) {
            onClick();
        }
    }
}
```

#### 按键事件分发

在某个 Activity 界面点击了遥控器的某个按键，然后这个按键事件在当前这个 Activity 里的分发处理流程。

```java
// 事件分发
public boolean dispatchKeyEvent(KeyEvent event) {
    if (条件1) {
        return true;    //焦点不移动，停止事件分发
    } else if (条件2) {
        return false;    //焦点移动，停止事件分发
    } else {
        return super.dispatchKeyEvent(event);
    }
}

// 事件处理
public void handleKeyEvent(KeyEvent event) {
    if (!onKeyEvent(event)) {
        getParent.onKeyEvent(event);
    }
}

// onKey,onKeyDown/onKeyUp,onClick调用关系
public void consumeEvent(KeyEvent event) {
    if (setOnKeyListener) {
        onKey();
        if (!onKey()) {
            onKeyDown(event); //onKeyUp(event)
            if (setOnClickListener) {
                onClick();
            }
        }
    } else {
        onKeyDown(event); // onKeyUp(event)
        if (setOnClickListener) {
            onClick();
        }
    }
}
```

#### 滑动冲突

**场景一：横向的 HorizontalScrollView 嵌套竖向的 ListView，默认情况下在 ListView 内部左右滑动可以让 HorizontalScrollView 左右滑动。
**

```java
// 内部拦截：重写HorizontalScrollView#onInterceptTouchEvent。
// 'return x > lastX' 表示左滑拦截，右滑不拦截。
public class MyHorizontalScrollView extends HorizontalScrollView {
    public MyHorizontalScrollView(Context context) {
        super(context);
    }
    public MyHorizontalScrollView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }
    public MyHorizontalScrollView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }
    int lastX;
    int lastY;
    @Override
    public boolean onInterceptTouchEvent(MotionEvent event) {
        int x = (int) event.getX();
        int y = (int) event.getY();
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
            case MotionEvent.ACTION_UP: {
                break;
            }
            case MotionEvent.ACTION_MOVE: {
                return x > lastX;
            }
        }
        lastX = x;
        lastY = y;
        return super.onInterceptTouchEvent(event);
    }
}
```

**场景二：竖向的 ScrollView 嵌套竖向的 ListView ，默认情况下 ListView 内部无法左右滑动。**

```java
// 内部拦截：MyScrollView不拦截MotionEvent.ACTION_DOWN事件。
// MyListView 内部单独处理事件，'curY > lastY' 表示 ListView 内部可以向上滑动，不能向下滑动。
public class MyScrollView extends ScrollView {
    public MyScrollView(Context context) {
        super(context);
    }
    public MyScrollView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }
    public MyScrollView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }
    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            return false;
        } else {
            return true;
        }
    }
}


public class MyListView extends ListView {
    public MyListView(Context context) {
        super(context);
    }
    public MyListView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }
    public MyListView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }
    int lastX;
    int lastY;
    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        switch (ev.getAction()) {
            case MotionEvent.ACTION_DOWN:
                getParent().getParent().requestDisallowInterceptTouchEvent(true);
                break;
            case MotionEvent.ACTION_MOVE:
                int curX = (int) ev.getX();
                int curY = (int) ev.getY();
                if (curY > lastY) {
                    getParent().getParent().requestDisallowInterceptTouchEvent(false);
                    return false;
                }
                break;
            case MotionEvent.ACTION_UP:
                break;
        }
        lastX = (int) ev.getX();
        lastY = (int) ev.getY();
        return super.dispatchTouchEvent(ev);
    }
}
```

#### 参考

+ [Android解决滑动冲突](https://blog.csdn.net/weixin_45927121/article/details/124873613)
+ [Android Tv 中的按键事件 KeyEvent 分发处理流程](https://www.cnblogs.com/dasusu/p/7403698.html)
+ [这次，我把Android事件分发机制翻了个遍](https://zhuanlan.zhihu.com/p/139970673)