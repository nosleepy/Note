---
title: GWN7703相关
date: 2023-06-08 00:00:00
tags:
categories:
- GWN
---

#### OpenWrt系统结构

+ /etc/config/dropbear：ssh服务
+ /etc/config/system：时区
+ /etc/config/firewall：防火墙相关

#### C语言基础

+ [typedef函数指针用法](https://blog.csdn.net/qll125596718/article/details/6891881)

#### Log调试

```shell
logread -f
logread -f | grep hello
```

#### 快捷编译脚本 auto_compiler.sh

```shell
#!/bin/bash
tag=$1
module=""
echo "tag = $tag"
if [ "$tag" == "sg" ]
then
  module="signaling_gateway"
elif [ "$tag" == "cfmanager" ]
then
  module="cfmanager"
fi
echo "module = $module"
cd $module
./build.sh gwn7703
adb push /media/wlzhou/bak/gwn73xx/image_build/packages/files/$module/ptp/gwn7703/usr/sbin/$tag /usr/sbin/
adb shell /etc/init.d/$tag restart
cd -
```

编译命令

```shell
./auto_compiler.sh sg // 编译 sg 模块
./auto_compiler.sh cfmanager // 编译 cfmanager 模块
```

#### 本地配置生效流程

1. 页面修改配置，比如ip地址由dhcp获取修改为静态ip，修改的配置项被写入/etc/config/grandstream
2. 页面触发调用/etc/init.d/grandstream reload
3. 脚本/etc/init.d/grandstream调用命令gsconfig --all解析/etc/config/grandstream生成其他配置文件，都存放在目录/etc/config/下面，然后调用命令reload_config
4. 命令reload_config计算/etc/config/所有配置文件的MD5值，与上一次的计算结果比较，若发生变化，会调用ubus命令通知那些配置发生了修改，此处为：
ubus call service event '{ "type": "config.change", "data": { "package": "network" }}'
5. 由于/etc/init.d/network脚本中有使用下面命令注册触发器，/etc/init.d/network reload将会被调用，然后修改的配置会生效
procd_add_reload_trigger network wireless dhcp

#### 修改gwn7703系统设置-基础设置流程

进入web管理后台修改设备名称为gwn3077

![](https://cdn.jsdelivr.net/gh/nosleepy/picture@master/img/gwn7703_web_basic_request.png)

adb连接gwn7703,使用 logread -f 命令查看日志

```
logread -f
```

![](https://cdn.jsdelivr.net/gh/nosleepy/picture@master/img/gwn7703_basic_log.png)

从日志可以看出大致流程：web -> signaling_gateway -> cfmanager

signaling_gateway主要是维护与页面的通信, 处理前端下发的信令, 转发到各个模块处理, sg模块基本不涉及大量的业务处理

```
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 17
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 29
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 19
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 71
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 18
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 12
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     post  = /signaling_gateway
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     host: = 192.168.124.130
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     connection: = close
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     origin: = https://192.168.124.130
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     http/1.1  = HTTP/1.1
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     accept: = application/json, text/plain, */*
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     accept-encoding: = gzip, deflate, br
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     accept-language: = zh-CN,zh;q=0.9
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     content-length: = 261
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     content-type: = application/json
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     referer: = https://192.168.124.130/
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     user-agent: = Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     uri-args = _main_=2,_sub_=basic
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     x-real-ip: = 192.168.124.128
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     x-forwarded-for: = 192.168.124.128
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: URI Arg 1: _main_=2
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: URI Arg 2: _sub_=basic
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: pss->content_type = 3
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 13
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 14
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: LWS_CALLBACK_HTTP_BODY_COMPLETION: 0x835d9e0
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: magicID: (len 9) '253635645'
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: hashID: (len 16) 'ca2HwzKJWdCiQpyb'
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: userID: (len 32) '40032ae2cb8aad4ec3997d071d7de66e'
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: protocol: '1'
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: cmdMaintype: '2'
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: cmdMain = 2, hashID = ca2HwzKJWdCiQpyb, userID = 40032ae2cb8aad4ec3997d071d7de66e, cmdMaintype = (null), cmdSubtype = basic, cmdSection = { "cmdSubtype": "basic", "devProductName": "GWN3077222", "country": "688", "timeZone": "Pacific\/Midway", "ntpSer...
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: handle_command cmdMain = 2, subCmd = basic
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: message_req_build msg_str = {"hashID":"ca2HwzKJWdCiQpyb","id":54,"method":"set basic","params":{"cmdSubtype":"basic","devProductName":"GWN3077222","country":"688","timeZone":"Pacific\/Midway","ntpServer":"pool.ntp.org"}}
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: ubus_wrapper_call source = 2
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: cfubus_handle_sg_info: recv id:54,hashID:ca2HwzKJWdCiQpyb,method:set basic
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: cfubus_handle_sg_info: id = 54, hashID = ca2HwzKJWdCiQpyb, method = set basic, params_attr = {"cmdSubtype":"basic","devProductName":"GWN3077222","country":"688","timeZone":"Pacific\/Midway","ntpServer":"pool.ntp.org"}
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: sgreq_set_basic: path = cfmanager.basic.timeZone
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: config_uci_set: path:cfmanager.basic.timeZone   value:Pacific/Midway
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: config_commit: synchronize files :cfmanager
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: sgreq_set_basic: sgreq_set_basic CFMANAGER_CONFIG_NAME = cfmanager
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: cfparse_load_file: load cfmanager, section=9, force_load=0
Wed Jun  7 18:51:24 2023 daemon.warn cfmanager: cm_vltree_update: update cfmanager section  type 'basic', name 'basic'
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: config_uci_set: path:system.system.timezone   value:SST11
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: cm_load_cfmanager: Commit package system
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: cfparse_load_file: load system, section=0, force_load=0
Wed Jun  7 18:51:24 2023 daemon.warn cfmanager: cfparse_sys_vltree_update: update system section 'system'
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 16
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 16
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 5
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 30
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 17
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 29
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 19
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 71
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 18
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 12
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     post  = /signaling_gateway
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     host: = 192.168.124.130
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     connection: = close
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     origin: = https://192.168.124.130
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     http/1.1  = HTTP/1.1
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     accept: = application/json, text/plain, */*
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     accept-encoding: = gzip, deflate, br
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     accept-language: = zh-CN,zh;q=0.9
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     content-length: = 160
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     content-type: = application/json
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     referer: = https://192.168.124.130/
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     user-agent: = Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     uri-args = _main_=3,_sub_=basic
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     x-real-ip: = 192.168.124.128
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway:     x-forwarded-for: = 192.168.124.128
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: URI Arg 1: _main_=3
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: URI Arg 2: _sub_=basic
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: pss->content_type = 3
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 13
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 14
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: LWS_CALLBACK_HTTP_BODY_COMPLETION: 0x835d9e0
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: magicID: (len 9) '253635645'
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: hashID: (len 16) 'ca2HwzKJWdCiQpyb'
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: userID: (len 32) '40032ae2cb8aad4ec3997d071d7de66e'
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: protocol: '1'
Wed Jun  7 18:51:24 2023 daemon.notice signaling_gateway: cmdMaintype: '3'
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: cmdMain = 3, hashID = ca2HwzKJWdCiQpyb, userID = 40032ae2cb8aad4ec3997d071d7de66e, cmdMaintype = (null), cmdSubtype = basic, cmdSection = { "cmdSubtype": "basic" }
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: handle_command cmdMain = 3, subCmd = basic
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: message_req_build msg_str = {"hashID":"ca2HwzKJWdCiQpyb","id":55,"method":"get basic","params":{"cmdSubtype":"basic"}}
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: ubus_wrapper_call source = 2
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: cfubus_handle_sg_info: recv id:55,hashID:ca2HwzKJWdCiQpyb,method:get basic
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: cfubus_handle_sg_info: id = 55, hashID = ca2HwzKJWdCiQpyb, method = get basic, params_attr = {"cmdSubtype":"basic"}
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 16
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 16
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 5
Wed Jun  7 18:51:24 2023 daemon.warn signaling_gateway: http_callback | reason = 30
```

搜索日志 URI Arg 可以定位到 protocol.c 文件中的 http_callback 方法

```c
int http_callback(
    struct lws *wsi,
    enum lws_callback_reasons reason,
    void *user,
    void *in,
    size_t len
)
```

http_callback 定义在 main.c 文件中

```c
static const struct lws_protocols protocols[] = {
    {"http", http_callback, sizeof(struct per_session_post_data), 0},
    {"websocket", conn_callback, sizeof(struct conn), 0},
    {NULL, NULL, 0, 0}
};
```

```c
case LWS_CALLBACK_HTTP:
    /* non-mount-handled accesses will turn up here */

    /* dump the headers */
    do {
        c = lws_token_to_string(n);
        if (!c) {
            n++;
            continue;
        }

        hlen = lws_hdr_total_length(wsi, n);
        if (!hlen || hlen > (int) sizeof(buffer) - 1) {
            n++;
            continue;
        }

        if (lws_hdr_copy(wsi, (char * ) buffer, sizeof(buffer), n) < 0)
            lwsl_notice("    %s (too big)\n", (char * ) c);
        else {
            buffer[sizeof(buffer) - 1] = '\0';

            lwsl_notice("    %s = %s\n", (char * ) c, buffer);
        }
        n++;
    } while (c);

    /* dump the individual URI Arg parameters */

    n = 0;
    while (lws_hdr_copy_fragment(wsi, (char * ) buffer, sizeof(buffer),
            WSI_TOKEN_HTTP_URI_ARGS, n) > 0) {
        lwsl_notice("URI Arg %d: %s\n", ++n, buffer);
    }

    lws_hdr_copy(wsi, pss - > real_ip, sizeof(pss - > real_ip), WSI_TOKEN_X_FORWARDED_FOR);
    pss - > role = USER_SESSION_LOCAL;

    lws_hdr_copy(wsi, (char * ) buffer, sizeof(buffer), WSI_TOKEN_HTTP_CONTENT_TYPE);
    if (strncmp((char * ) buffer, "multipart/form-data", strlen("multipart/form-data")) == 0) {
        pss - > content_type = CNT_MULTIPART_FORM_DATA;
    } else if (strncmp((char * ) buffer, "application/x-www-form-urlencoded", strlen("application/x-www-form-urlencoded")) == 0) {
        pss - > content_type = CNT_APPLICATION_X_WWW_FORM_URLENCODED;
    } else if (strncmp((char * ) buffer, "application/json", strlen("application/json")) == 0) {
        pss - > content_type = CNT_APPLICATION_JSON;
    } else {
        pss - > content_type = CNT_UNKOWN;
    }
    return 0;
```

当 reason == LWS_CALLBACK_HTTP 时, _main_=2和_sub_=basic对应着请求url拼接的参数signaling_gateway?_main_=2&_sub_=basic

```c
case LWS_CALLBACK_HTTP_BODY_COMPLETION:
    lwsl_notice("LWS_CALLBACK_HTTP_BODY_COMPLETION: %p\n", wsi);
    /* call to inform no more payload data coming */
    if (pss - > content_type == CNT_APPLICATION_X_WWW_FORM_URLENCODED) {
        lws_spa_finalize(pss - > spa);
        if (pss - > spa)
            for (n = 0; n < (int) LWS_ARRAY_SIZE(param_names); n++) {
                if (!lws_spa_get_string(pss - > spa, n))
                    lwsl_notice("%s: undefined\n", param_names[n]);
                else
                    lwsl_notice("%s: (len %d) '%s'\n",
                        param_names[n],
                        lws_spa_get_length(pss - > spa, n),
                        lws_spa_get_string(pss - > spa, n));
            }
    } else if (pss - > content_type == CNT_APPLICATION_JSON) {
        json_object_object_foreach(pss - > jpa, key, val) {
            switch (json_object_get_type(val)) {
                case json_type_object:
                    break;
                case json_type_array:
                    break;
                case json_type_string:
                    lwsl_notice("%s: (len %d) '%s'\n", key,
                        json_object_get_string_len(val), json_object_get_string(val));
                    break;
                case json_type_boolean:
                    break;
                case json_type_int:
                    {
                        lwsl_notice("%s: '%d'\n", key, json_object_get_int(val));
                        break;
                    }
                default:
                    break;
            }
        }
    }
    pss - > completed = 1;
    handle_http_cmd(wsi, pss);
    break;
```

当 reason = LWS_CALLBACK_HTTP_BODY_COMPLETION 时,解析请求体的json数据

由 pss 保存http请求的数据

```c
struct per_session_post_data {
    struct lws_spa *spa;
    json_object *jpa;

    int  role;
    int  content_type;
    char real_ip[MAX_ADDRESS_LEN + 1];
    //char result[LWS_PRE + LWS_RECOMMENDED_MIN_HEADER_SPACE];
    char *result;
    int   result_len;

    /* For upload file */
    char filename[64];
    long file_length;
#if !defined(LWS_WITH_ESP32)
    lws_filefd_type fd;
#endif
    uint8_t completed:1;
    uint8_t sent_headers:1;
    uint8_t sent_body:1;

    time_t  login_limit_time;
};
```

在 handle_http_cmd 方法中处理 http 请求

```c
if ( pss->content_type == CNT_APPLICATION_JSON ) {
        do {
            if ( !json_object_object_get_ex( pss->jpa, "magicID", &current_obj ) ) {
                lwsl_err( "Message is not implemented: miss magicID\n" );
                errcode = ERRCODE_PARAMETER_ERROR;
                errmsg = "Miss magicID";
                break;
            }

            magic = json_object_get_int( current_obj );
            if ( magic != MAGICID_INT_VALUE ) {
                lwsl_err( "magicID %d is not legal\n", magic );
                errcode = ERRCODE_PARAMETER_ERROR;
                errmsg = "magicID illegal";
                break;
            }

            if ( !json_object_object_get_ex( pss->jpa, "cmdMaintype", &current_obj ) ) {
                lwsl_err( "Message is not implemented: miss cmdMaintype\n" );
                errcode = ERRCODE_PARAMETER_ERROR;
                errmsg = "Miss cmdMaintype";
                break;
            }
            cmdMain = json_object_get_int( current_obj );

            if ( !json_object_object_get_ex( pss->jpa, "protocol", &current_obj ) ) {
                lwsl_err( "Message is not implemented: miss protocol\n" );
                errcode = ERRCODE_PARAMETER_ERROR;
                errmsg = "Miss protocol";
                break;
            }
            proto = json_object_get_int( current_obj );
            UNUSED(proto);

            if ( !json_object_object_get_ex( pss->jpa, "hashID", &current_obj ) ) {
                lwsl_err( "Message is not implemented: miss hashID\n" );
                errcode = ERRCODE_PARAMETER_ERROR;
                errmsg = "Miss hashID";
                break;
            }
            hashID = json_object_get_string( current_obj );

            if ( json_object_object_get_ex( pss->jpa, "userID", &current_obj ) ) {
                /* { "userID" : null }. Avoid crashes */
                if ( json_object_get_type( current_obj ) == json_type_string ) {
                    userID = json_object_get_string( current_obj );
                }
            }

            if ( !json_object_object_get_ex( pss->jpa, "cmdSection", &current_obj ) ) {
                lwsl_err( "Message is not implemented: miss cmdSection\n" );
                errcode = ERRCODE_PARAMETER_ERROR;
                errmsg = "Miss cmdSection";
                break;
            }

            cmdSection = json_object_to_json_string( current_obj );

            param_object = json_tokener_parse( cmdSection );
            if ( !param_object ) {
                errcode = ERRCODE_PARAMETER_ERROR;
                errmsg = "CmdSection is not in JSON format";
                break;
            }

            if ( !json_object_object_get_ex( param_object, "cmdSubtype", &current_obj ) ) {
                json_object_put( param_object );
                errcode = ERRCODE_PARAMETER_ERROR;
                errmsg = "Miss cmdSubtype";
                break;
            }

            strncpy( cmdSubtype, json_object_get_string( current_obj ), sizeof(cmdSubtype) - 1 );

            errcode = handle_command( wsi, cmdMain, hashID, userID, param_object );
            json_object_put( param_object );
        } while(0);
    }
```

依次获取到 magic、cmdMain、proto、hashID、cmdSection

```
Wed Jun  7 01:15:08 2023 daemon.warn signaling_gateway: cmdMain = 3, hashID = ca2HwzKJWdCiQpyb, userID = 2f119a5ee6cccdd4689be7370bc324d8, cmdMaintype = (null), cmdSubtype = basic, cmdSection = { "cmdSubtype": "basic" }
```

执行 handle_command 方法得到返回码

```c
errcode = handle_command( wsi, cmdMain, hashID, userID, param_object );
```

根据 cmdMain 执行不同流程

```c
    switch( cmdMain ) {
        case CMD_MAIN_CTRL:
            result = handle_ctrl_cmd( wsi,
                hashID, subCmd, params );
            break;
        case CMD_MAIN_SET:
            result = handle_set_cmd( wsi,
                hashID, subCmd, params );
            break;
        case CMD_MAIN_GET:
            result = handle_get_cmd( wsi,
                hashID, subCmd, params );
            break;
        case CMD_MAIN_NOTIFY:
            result = ERRCODE_SUCCESS;
            break;
        case CMD_MAIN_MANAGE:
            result = handle_manage_cmd( wsi,
                hashID, subCmd, params );
            break;
        case CMD_MAIN_EXT:
            result = handle_ext_cmd( wsi,
                hashID, subCmd, params );
            break;
        default:
            lwsl_err( "Failed to found method to handle message(main:%d, sub:%s)\n",
                cmdMain, subCmd );
            break;
    }
```

修改设备名称属于 set 操作, 从日志也可以看出 cmdMain 为2, 继续执行 handle_set_cmd 方法, 其中 subCmd 为 basic

```c
result = handle_set_cmd( wsi, hashID, subCmd, params );

int handle_set_cmd(
    struct lws  *wsi,
    const char  *hash_id,
    const char  *cmd,
    json_object *params
)
{
    char command[32];
    int rc = ERRCODE_SUCCESS;

    snprintf( command, sizeof( command ), "set %s", cmd ); // cmd = basic, command =  set basic
    rc = message_req_build( wsi, hash_id, command, CMD_MAIN_SET, cmd, params ); // 消息请求构建

    return rc;
}

int
message_req_build(
    struct lws *wsi,
    const char *hashID,
    const char *method,
    const int   cmdMainType,
    const char *cmdSubType,
    json_object *jo
)
{
    char *msg_str = NULL;
    int ret = 0;

    msg_str = jsonrpc_req_string( hashID, method, jo ); // 转换为json数据
    if ( msg_str == NULL ) {
        lwsl_err( "Build message( %s ) failed\n", method );
        return ERRCODE_INTERNAL_ERROR;
    }

    message_singal_build( &message, msg_str ); // string 转 blob_buf 结构
    free( msg_str );

    if ( DEBUG ) {
        char *debug_str = blobmsg_format_json_indent( message.head, true, -1 );
        lwsl_notice( "send message: %s\n", debug_str );
        free( debug_str );
    }

    ret = ubus_wrapper_call( wsi,
        "cfmanager.sg", "handle_sg_info",
        cmdMainType, cmdSubType, hashID, message.head );

    if ( ret != 0 ) {
        lwsl_err( "Send message( %s ) failed\n", method );
        return ERRCODE_INTERNAL_ERROR;
    }

    return ERRCODE_SUCCESS;
}
```

msg_str 内容如下

```
Wed Jun  7 01:49:11 2023 daemon.warn signaling_gateway: message_req_build msg_str = {"hashID":"ca2HwzKJWdCiQpyb","id":27,"method":"set basic","params":{"cmdSubtype":"basic","devProductName":"GWN3077","country":"688","timeZone":"America\/Phoenix","ntpServer":"pool.ntp.org"}}
```

接着调用 ubus_wrapper_call 方法通过 ubus 将请求交给 cfmanager 模块处理

```c
ret = ubus_wrapper_call(wsi,"cfmanager.sg", "handle_sg_info", cmdMainType, cmdSubType, hashID, message.head );

int ubus_wrapper_call(
    struct lws *wsi,
    const char *object,
    const char *method,
    const int   cmdMainType,
    const char *cmdSubType,
    const char *hashID,
    struct blob_attr *params
)
{
    int source, result, timeout;
    source = message_type( wsi );
    switch (source) {
        case PROTOCOL_SOURCE_WS: {
            result = uproxy_call_async( wsi, object, method, cmdMainType, cmdSubType, hashID, params );
            break;
        }
        case PROTOCOL_SOURCE_HTTP: {
            result = uproxy_call( wsi, object, method, cmdMainType, cmdSubType, hashID, params, timeout );
            break;
        }
        default: {
            const struct lws_protocols *protocol = lws_get_protocol( wsi );
            lwsl_warn( "Unkownn protocol %s\n", protocol->name );
            result = -1;
            break;
        }
    }
    return result;
}

int uproxy_call( // http 类型
    struct lws *wsi,
    const char *object,
    const char *method,
    const int   cmd_main,
    const char *cmd_sub,
    const char *hash_id,
    struct blob_attr *params,
    int timeout
)
{
    struct server *server = NULL;
    struct uproxy_request *uproxy_req;
    uint32_t object_id;
    int result;
    server = lws_context_user( lws_get_context( wsi ) );
    result = ubus_lookup_id( server->ubus_ctx, object, &object_id );
    if ( result != UBUS_STATUS_OK ) {
        lwsl_err("lookup %s failed: %s\n", object, ubus_strerror(result));
        return -1;
    }
    uproxy_req= uproxy_create( wsi, object, method, cmd_main, cmd_sub, hash_id, params ); // 由cfmanager模块写入数据
    if ( !uproxy_req )
        return -1;
    result = ubus_invoke( server->ubus_ctx, object_id, method, params, uproxy_call_cb, uproxy_req, timeout );
    if ( result == UBUS_STATUS_OK ) {
        message_send( uproxy_req->reply_mesg.head, wsi );
    }
    else {
        lwsl_err( "invoke failed: %s\n", ubus_strerror(result) );
        blobmsg_add_u32( &uproxy_req->reply_mesg, "retVal", ERRCODE_REQUEST_TIMEOUT );
        blobmsg_add_string( &uproxy_req->reply_mesg, "retMsg", ubus_strerror(result) );
        blobmsg_add_u32( &uproxy_req->reply_mesg, "cmdMaintype", uproxy_req->cmd_main );
        blobmsg_add_string( &uproxy_req->reply_mesg, "cmdSubtype", uproxy_req->cmd_sub );
        blobmsg_add_string( &uproxy_req->reply_mesg, "hashID", uproxy_req->hash_id );
        message_send( uproxy_req->reply_mesg.head, wsi );
    }
    uproxy_destory( uproxy_req );
    return 0;
}

void message_send(
    struct blob_attr *attr,
    struct lws *wsi
)
{
    char *reply_mesg = NULL;
    int   source = PROTOCOL_SOURCE_UNKOWN;
    reply_mesg = blobmsg_format_json( attr, true ); // blob_buf 结构转 string
    if ( !reply_mesg )
        return;
    source = message_type( wsi );
    switch (source) {
        case PROTOCOL_SOURCE_WS:
            conn_queue_send( wsi, reply_mesg );
            break;
        case PROTOCOL_SOURCE_HTTP: {
            struct per_session_post_data *pss = lws_wsi_user( wsi );
            pss->result_len = strlen(reply_mesg);
            pss->result = calloc( 1, LWS_PRE + pss->result_len + 1 );
            if ( !pss->result ) {
                lwsl_err( "failed to alloc http response buf" );
                break;
            }
            memcpy( pss->result + LWS_PRE, reply_mesg, pss->result_len );
            lws_callback_on_writable( wsi );
            break;
        }
        default: {
            const struct lws_protocols *protocol = lws_get_protocol( wsi );
            lwsl_warn( "unkownn protocol to send %s\n", protocol->name );
            break;
        }
    }
    free( reply_mesg );
}
```

message_send 方法将执行结果返回给浏览器

```json
{"id":26,"retVal":0,"retMsg":"data processing successful","cmdMaintype":2,"cmdSubtype":"basic","hashID":"ca2HwzKJWdCiQpyb"}
```

![](https://cdn.jsdelivr.net/gh/nosleepy/picture@master/img/gwn7703_web_basic_response.png)

继续查看 cfmanager 的处理过程

搜索关键信息 'recv id:' 定位到 cfmanager 模块的 cfubus_handle_sg_info 方法中

```c
//ubus.c

static struct ubus_object_type cfmanager_sg_object_type =
    UBUS_OBJECT_TYPE( "cfmanager.sg", cfmanager_sg_object_methods );

static struct ubus_method cfmanager_sg_object_methods[] = {
    UBUS_METHOD( "handle_sg_info", cfubus_handle_sg_info, cfubus_sg_info_policy ),
};

static struct blobmsg_policy cfubus_sg_info_policy[__SG_MAX] = {
    [SG_ID] = { .name = "id", .type = BLOBMSG_TYPE_INT32 },
    [SG_HASHID] = { .name = "hashID", .type = BLOBMSG_TYPE_STRING },
    [SG_METHOD] = { .name = "method", .type = BLOBMSG_TYPE_STRING },
    [SG_PARAMS] = { .name = "params", .type = BLOBMSG_TYPE_TABLE },
};

static int cfubus_handle_sg_info(
    struct ubus_context *ctx,
    struct ubus_object *obj,
    struct ubus_request_data *req,
    const char *method,
    struct blob_attr *msg
)
{
    struct blob_attr *tb[__SG_MAX];
    struct blob_attr *params_attr;
    struct sg_params sg_params;
    int id = 0;
    int i = 0;
    int find = 0;
    int error = 0;
    char method_str[METHOD_LEN] = { 0 };
    char hashID[HASH_SIZE] = { 0 };
    char temp_buf[BUF_LEN_128] = { 0 };

    blobmsg_parse( cfubus_sg_info_policy,
            __SG_MAX,
            tb,
            blob_data( msg ),
            blob_len( msg ) );

    if( tb[SG_ID] )
        id = blobmsg_get_u32( tb[SG_ID] );
    if( tb[SG_HASHID] )
        strncpy( hashID, blobmsg_get_string( tb[SG_HASHID] ), sizeof( hashID ) - 1 );
    if( tb[SG_METHOD] )
        strncpy( method_str, blobmsg_get_string( tb[SG_METHOD] ), sizeof( method_str ) - 1 );
    if( tb[SG_PARAMS] )
        params_attr = tb[SG_PARAMS];

    cfmanager_log_message( L_DEBUG, "recv id:%d,hashID:%s,method:%s\n", id, hashID, method_str );

    if( !id || hashID[0] == '\0' || method_str[0] == '\0' ) {
        error = ERRCODE_MESSAGE_WRONG_FROMAT;
        goto error_out;
    }

    memset( &sg_params, 0, sizeof( sg_params ) );
    sg_params.id = id;
    sg_params.hashID = hashID;
    sg_params.method = method_str;

    for( i = 0; i < sg_handle_policy_sz; i++ ) {
        if( 0 == strcmp( sg_hp[i].method_name, method_str ) ) {  // 匹配到set basic方法,调用sgreq_set_basic函数
            sg_hp[i].cb( ctx, params_attr, req, &sg_params );
            find = 1;
        }
    }

    if( !find ) {
        error = ERRCODE_METHOD_NOT_FOUND;
        cfmanager_log_message( L_ERR, "No corresponding %s processing policy was found", method_str );
        goto error_out;
    }

    return UBUS_STATUS_OK;

error_out:
    blob_buf_init( &reply, 0 );

    blobmsg_add_string( &reply, "hashID", hashID );
    blobmsg_add_u32( &reply, "id", id );

    cfubus_wss_error_state_handle( error, temp_buf, sizeof( temp_buf ) );
    blobmsg_add_u32( &reply, "retVal", error );
    blobmsg_add_string( &reply, "retMsg", temp_buf );

    ubus_send_reply( ctx, req, reply.head );
    blob_buf_free( &reply );

    return UBUS_STATUS_INVALID_ARGUMENT;
}
```

method 为 set basic, msg 为跨进程通信传过来的 blob_attr 类型数据, 获取到 id、hashID、method、params_attr

```
Wed Jun  7 02:46:19 2023 daemon.debug cfmanager: cfubus_handle_sg_info: recv id:273,hashID:ca2HwzKJWdCiQpyb,method:set basic
Wed Jun  7 02:46:19 2023 daemon.debug cfmanager: cfubus_handle_sg_info: id = 273, hashID = ca2HwzKJWdCiQpyb, method = set basic, params_attr = {"cmdSubtype":"basic","devProductName":"GWN3077","country":"688","timeZone":"America\/Phoenix","ntpServer":"pool.ntp.org"}
```

回调 static struct sg_handle_policy sg_hp[] 中的 sgreq_set_basic 方法

```c
static struct sg_handle_policy sg_hp[] = {
    //ctrl request
    { "vpn service", sgreq_ctrl_vpn_service },

    //set request
    { "set upgrade auto", sgreq_set_upgrade_auto },
    { "set wan", sgreq_set_wan },
    { "set lan", sgreq_set_lan },
    { "set access", sgreq_set_access },
    { "set global access", sgreq_set_global_access },
    { "set schedule access", sgreq_set_schedule_access },
    { "set acl", sgreq_set_acl },
    { "set qos", sgreq_set_qos },
    { "set usb share", sgreq_set_usb_share },
    { "set static router", sgreq_set_static_router },
    { "set controller", sgreq_set_controller },
    { "set general", sgreq_set_general },
    { "set basic", sgreq_set_basic },
    { "set manage ap or mesh", sgreq_set_manage_ap_mesh },
    { "set ap", sgreq_set_ap },
    { "set vpn service", sgreq_set_vpn_service },
    { "set vpn split tunneling", sgreq_set_vpn_split_tunneling },
    { "set port mapping", sgreq_set_port_mapping },
    { "set dmz", sgreq_set_dmz },
    { "set upnp", sgreq_set_upnp },
    { "set ddns", sgreq_set_ddns },
    { "set ipv4 static route", sgreq_set_ipv4_static_route },
    { "set alert notification config", sgreq_set_alert_notification_config },
#ifndef GWN77XX
    { "set guest ssid", sgreq_set_guest_ssid },
#endif
    { "set mesh ssid", sgreq_set_mesh_ssid },
    { "set client limit", sgreq_set_client_limit },
    { "set firewall", sgreq_set_firewall },
    { "set hostname", sgreq_set_hostname },
    //Add for snmp start
    { "set snmp", sgreq_set_snmp },
    //Add for snmp end
    { "set tr069", sgreq_set_tr069 },
};

void sgreq_set_basic(
    struct ubus_context *ctx,
    struct blob_attr *data,  // blob_attr数据
    struct ubus_request_data *req, // 写入返回信息
    struct sg_params* sg_params // 自定义节点
)
{
    struct blob_attr *tb[__BASIC_SET_MAX];
    struct blob_attr *cm_tb[__BASIC_SET_MAX];
    struct cm_config *cm_cfg = NULL;
    char path[LOOKUP_STR_SIZE] = { 0 };
    char value[BUF_LEN_128] = { 0 };
    int error_state = 0;
    int i = 0;
    int flag = 0;
#ifdef GWN77XX
    struct cm_config *cm_wireless_cfg = NULL;
    struct blob_attr *tb_wireless[__WIRELESS_MAX];
    bool need_reset_channel = false;
    int channel_width = 0;
    int channel = 0;

    cm_wireless_cfg = util_get_vltree_node( &cm_wireless_vltree, VLTREE_CM_TREE, "wireless" );
    if ( cm_wireless_cfg ) {
        blobmsg_parse( wireless_policy,
            __WIRELESS_MAX,
            tb_wireless,
            blob_data( cm_wireless_cfg->cf_section.config ),
            blob_len( cm_wireless_cfg->cf_section.config ) );
    }
#endif

    blobmsg_parse( basic_system_policy,
        __BASIC_SET_MAX,
        tb,
        blobmsg_data( data ),
        blobmsg_len( data ) );

    cm_cfg = util_get_vltree_node( &cm_basic_system_vltree, VLTREE_CM_TREE, "basic" );
    if( !cm_cfg ) {
        cfmanager_log_message( L_DEBUG, "No basic information found in %s\n", CFMANAGER_CONFIG_NAME );

        error_state = config_set_section( CFMANAGER_CONFIG_NAME, "basic", "basic" );
        if ( error_state ) {
            cfmanager_log_message( L_ERR, "Creat basic in %s\n", CFMANAGER_CONFIG_NAME );
            goto return_value;
        }
    }

    if ( cm_cfg ) {
        blobmsg_parse( basic_system_policy,
            __BASIC_SET_MAX,
            cm_tb,
            blob_data( cm_cfg->cf_section.config ),
            blob_len( cm_cfg->cf_section.config  ) );
    }

    for( i = 0; i < __BASIC_SET_MAX; i++ ) {
        if( !tb[i] ) {
            continue;
        }

        if( cm_tb[i] && sgreq_compar_attr( tb[i], cm_tb[i], basic_system_policy[i].type ) ) {
            continue;
        }

        sprintf( path, "%s.basic.%s", CFMANAGER_CONFIG_NAME, basic_system_policy[i].name );
        if( BLOBMSG_TYPE_BOOL == basic_system_policy[i].type ) {

            sprintf( value, "%d", blobmsg_get_bool( tb[i] ) );
            config_uci_set( path, value, 0 );
        }
        else if( BLOBMSG_TYPE_INT32 == basic_system_policy[i].type ) {

            sprintf( value, "%d", blobmsg_get_u32( tb[i] ) );
            config_uci_set( path, value, 0 );
        }
        else {
            config_uci_set( path, blobmsg_get_string( tb[i] ), 0 );
        }

#ifdef GWN77XX
        if ( i == BASIC_COUNTRY_CODE ) {
            channel_width = util_blobmsg_get_int( tb_wireless[WIRELESS_CHANNEL_WIDTH], 0 );
            channel = util_blobmsg_get_int( tb_wireless[WIRELESS_CHANNEL], 0 );

            // judge whether the current channel is available when country code is changed
            if ( channel ) {
                need_reset_channel = sgreq_judge_need_reset_channel( ctx, blobmsg_get_string( tb[i] ), channel, channel_width );

                // if the current channel is unavailable, config set channel auto
                if( need_reset_channel ) {
                    sprintf( path, "%s.wireless.channel", CFMANAGER_CONFIG_NAME );
                    config_uci_set( path, "0", 0 );
                }
            }
        }
#endif

        flag = 1;
    }

    if( !flag ) {
        cfmanager_log_message( L_DEBUG, "The mode basic is same\n" );
        goto return_value;
    }

    config_commit( CFMANAGER_CONFIG_NAME, false );
    cfparse_load_file( CFMANAGER_CONFIG_NAME, CM_VLTREE_BASIC, false );

#ifdef GWN77XX
    if ( need_reset_channel ) {
        cfparse_load_file( CFMANAGER_CONFIG_NAME, CM_VLTREE_WIRELESS, false );
    }
#endif

return_value:
    blob_buf_init( &reply, 0 );
    sgreq_return_must_info_to_sg( &reply, sg_params, error_state );
    ubus_send_reply( ctx, req, reply.head );
    blob_buf_free( &reply );

    return;
}
```

util_get_vltree_node 方法返回 uci 节点为 basic 的信息

```c
cm_cfg = util_get_vltree_node( &cm_basic_system_vltree, VLTREE_CM_TREE, "basic" );
```

使用 cat /ect/config/cfmanager 可以查看 cfmanager 文件配置信息, 截取 basic 相关的部分

```
//待补充
```

使用 uci show cfconfig 显示 cfmanager 文件配置

```
//待补充
```

将要更新的数据存储到 tb, 原始配置文件数据存储到 cm_tb, 比较各项信息, 相等就不做处理, 不相等调用 config_uci_set 方法操作 uci 接口修改配置, 然后调用 config_commit 方法使用 uci 相关修改生效, 之后调用 cfparse_load_file 方法重写加载 cfmanager 的配置。

```c
cfparse_load_file( CFMANAGER_CONFIG_NAME, CM_VLTREE_BASIC, false ); // CFMANAGER_CONFIG_NAME = cfmanager, CM_VLTREE_BASIC = 9

int cfparse_load_file(
    const char *config,
    int section,
    bool force_load
)
{
    cfmanager_log_message( L_DEBUG, "load %s, section=%d, force_load=%d\n", config, section, force_load );

    if ( strcmp( config, "tracks" ) == 0 ) {
        tracks_load();
    }
    else if ( strcmp( config, "wireless" ) == 0 ) {
        cfparse_load_wireless();
    }
    else if ( strcmp( config, "network" ) == 0 ) {
        cfparse_load_network();
    }
    else if ( strcmp( config, "dhcp" ) == 0 ) {
        cfparse_load_dhcp();
    }
    else if ( strcmp( config, "schedule" ) == 0 ) {
        cfparse_load_schedule();
    }
    else if ( strcmp( config, "qos" ) == 0 ) {
        cfparse_load_qos();
    }
    else if ( strcmp( config, "blackhole" ) == 0 ) {
        cfparse_load_blackhole();
    }
    else if ( strcmp( config, CFMANAGER_CONFIG_NAME ) == 0 ) {
        cm_load_cfmanager( section, force_load );
#ifndef GWN77XX
        cfmanager_resync_timer_start();
#endif
        cfubus_event_config_change();
    }
    else if ( strcmp( config, "mwan3" ) == 0 ) {
        cfparse_load_mwan3();
    }
    else if ( strcmp( config, "firewall" ) == 0 ) {
        cfparse_load_firewall();
    }
    else if ( strcmp( config, "system" ) == 0 ) {
         cfparse_load_sys();
    }
    else if ( strcmp( config, CF_CONFIG_NAME_GRANDSTREAM ) == 0 ) {
        cfparse_load_grandstream();
    }
    else if ( strcmp( config, "controller" ) == 0 ) {
        cfparse_load_controller();
    }
    else if ( strcmp( config, "upnpd" ) == 0 ) {
        cfparse_load_upnpd();
    }
    else if ( strcmp( config, "bwctrl" ) == 0 ) {
        cfparse_load_bwctrl();
    }
    else if ( strcmp( config, "samba" ) == 0 ) {
        cfparse_load_smb();
    }
    else if( strcmp( config, "tr069" ) == 0 ) {
        cfparse_load_tr069();
    }
    else {
    }
    return 0;
}
```

执行以下三行代码

```c
cm_load_cfmanager( section, force_load );
#ifndef GWN77XX
cfmanager_resync_timer_start();
#endif
cfubus_event_config_change();
```

首先重写加载 cfmanager 配置文件, section = 9 代表加载 basic 节点配置

```c
int
cm_load_cfmanager(
    int section,
    bool force_load
)
{
    struct vlist_tree *vltree = NULL;
    struct uci_package *package = NULL;
    int i = 0;
    int j = 0;
    int k = 0;

    package = cfparse_init_package( CFMANAGER_CONFIG_NAME );
    if ( !package ) {
        cfmanager_log_message( L_ERR, "load %s package failed\n", CFMANAGER_CONFIG_NAME );
        return -1;
    }

    if( CM_VLTREE_ALL == section ) { // 加载 cfmanager 配置全部节点
        for( i = 1; i < __CM_VLTREE_MAX; i++ ) {

            vltree = cm_vltree_info[i].vltree;
            if( !vltree ) {
                continue;
            }

            vlist_update( vltree );
        }
    }
    else {
        vltree = cm_vltree_info[section].vltree; // 只加载 basic 节点
        if( !vltree ) {
            cfmanager_log_message( L_DEBUG, "No corresponding binary tree was found\n" );

            return -1;
        }

        vlist_update( vltree );
    }

    cm_force_load_flag = force_load; // 是否强制加载

    if( CM_VLTREE_ALL == section ) {
        /* Load into the tree in the order of enumeration.
         * Ensure that the tree has been loaded while handling certain dependencies.
         */
        for( k = 1; k < __CM_VLTREE_MAX; k++ ) {

            if( !cm_vltree_info[k].key ) {
                continue;
            }

            cm_load_section( package, cm_vltree_info[k].key, k );
        }
    }
    else {
        cm_load_section( package, cm_vltree_info[section].key, section );
    }

    if( CM_VLTREE_ALL == section ) {
        for( i = 1; i < __CM_VLTREE_MAX; i++ ) {

            vltree = cm_vltree_info[i].vltree;
            if( !vltree ) {
                continue;
            }

            vlist_flush( vltree );
        }
    }
    else {
        vltree = cm_vltree_info[section].vltree;

        vlist_flush( vltree );
    }

    for( j = 1; j < __CM_CFG_MAX; j++ ) {
        if( cfg_option & BIT(j) ) {
            cfg_option &= ~BIT(j);
            cfmanager_log_message( L_DEBUG, "Commit package %s\n", cm_cfg_name[j].name );
            config_commit( cm_cfg_name[j].name, false );
            cfparse_load_file( cm_cfg_name[j].name, LOAD_ALL_SECTION, false );
        }
    }

    cm_force_load_flag = false;
    return 0;
}
```

获取到 vltree

```c
vltree = cm_vltree_info[section].vltree;

struct vlist_tree {
	struct avl_tree avl;

	vlist_update_cb update;
	bool keep_old;
	bool no_delete;

	int version;
};
```

cm_vltree_info 定义在 cfmanager.c 文件中

```c
const struct cm_vltree_info cm_vltree_info[__CM_VLTREE_MAX] = {
    [CM_VLTREE_WAN] = {
        .key = "wan",
        .vltree = &cm_wan_vltree,
        .policy_list = &cm_wan_policy_list,
        .hooker = CM_HOOKER_WAN
    },

    [CM_VLTREE_WIRELESS] = {
        .key = "wireless",
        .vltree = &cm_wireless_vltree,
        .policy_list = &cm_wireless_policy_list,
        .hooker = CM_HOOKER_WIRELESS
    },

    [CM_VLTREE_LAN] =   {
        .key = "lan",
        .vltree = &cm_lan_vltree,
        .policy_list = &cm_lan_policy_list,
        .hooker = CM_HOOKER_LAN
    },

    [CM_VLTREE_UPGRADE_AUTO] = {
        .key = "upgrade_auto",
        .vltree = &cm_upgrade_auto_vltree,
        .policy_list = &cm_pgrade_auto_policy_list,
        .hooker = CM_HOOKER_UPGRADE_AUTO
    },

#ifndef GWN77XX
    [CM_VLTREE_GUEST_SSID] = {
        .key = "guest_ssid",
        .vltree = &cm_guest_ssid_vltree,
        .policy_list = &cm_guest_ssid_policy_list,
        .hooker = CM_HOOKER_GUEST_SSID
    },
#endif

    [CM_VLTREE_ACCESS] = {
        .key = "access",
        .vltree = &cm_access_vltree,
        .policy_list = &cm_access_policy_list,
        .hooker = CM_HOOKER_ACCESS
    },

    [CM_VLTREE_GLOBAL_ACCESS] = {
        .key = "global_access",
        .vltree = &cm_global_access_vltree,
        .policy_list = &cm_global_access_policy_list,
        .hooker = CM_HOOKER_GLOBAL_ACCESS
    },

    [CM_VLTREE_SCHEDULE_ACCESS] = {
        .key = "schedule_access",
        .vltree = &cm_schedule_access_vltree,
        .policy_list = &cm_schedule_access_policy_list,
        .hooker = CM_HOOKER_SCHEDULE_ACCESS
    },

    [CM_VLTREE_BASIC] = {
        .key = "basic",
        .vltree = &cm_basic_system_vltree,
        .policy_list = &cm_basic_set_policy_list,
        .hooker = CM_HOOKER_BASIC_SYSTEM
    },

    [CM_VLTREE_CONTROLLER] = {
        .key = "controller",
        .vltree = &cm_controller_vltree,
        .policy_list = &cm_controller_policy_list,
        .hooker = CM_HOOKER_CONTROLLER
    },

    [CM_VLTREE_AP] = {
        .key = "ap",
        .vltree = &cm_ap_vltree,
        .policy_list = &cm_ap_policy_list,
        .hooker = CM_HOOKER_AP
    },

    [CM_VLTREE_GENERAL] = {
        .key = "general",
        .vltree = &cm_general_vltree,
        .policy_list = &cm_general_policy_list,
        .hooker = CM_HOOKER_GENERAL
    },

    [CM_VLTREE_VPN_SERVICE] = {
        .key = "vpn_service",
        .vltree = &cm_vpn_service_vltree,
        .policy_list = &cm_vpn_service_policy_list,
        .hooker = CM_HOOKER_VPN_SERVICE
    },

    [CM_VLTREE_VPN_SPLIT] = {
        .key = "vpn_split",
        .vltree = &cm_vpn_split_vltree,
        .policy_list = &cm_vpn_split_policy_list,
        .hooker = CM_HOOKER_VPN_SPLIT
    },

    [CM_VLTREE_PORT_MAPPING] = {
        .key = "port_mapping",
        .vltree = &cm_port_mapping_vltree,
        .policy_list = &cm_port_mapping_policy_list,
        .hooker = CM_HOOKER_PORT_MAPPING
    },

    [CM_VLTREE_DMZ] = {
        .key = "dmz",
        .vltree = &cm_dmz_vltree,
        .policy_list = &cm_dmz_policy_list,
        .hooker = CM_HOOKER_DMZ
    },

    [CM_VLTREE_UPNP] = {
        .key = "upnp",
        .vltree = &cm_upnp_vltree,
        .policy_list = &cm_upnp_policy_list,
        .hooker = CM_HOOKER_UPNP
    },

    [CM_VLTREE_DDNS] = {
        .key = "ddns",
        .vltree = &cm_ddns_vltree,
        .policy_list = &cm_ddns_policy_list,
        .hooker = CM_HOOKER_DDNS
    },

    [CM_VLTREE_STATIC_ROUTE_IPV4] = {
        .key = "ipv4_static_route",
        .vltree = &cm_static_route_ipv4_vltree,
        .policy_list = &cm_static_route_ipv4_policy_list,
        .hooker = CM_HOOKER_STATIC_ROUTE_IPV4
    },

    [CM_VLTREE_MESH_SSID] = {
        .key = "mesh_ssid",
        .vltree = &cm_mesh_ssid_vltree,
        .policy_list = &cm_mesh_ssid_policy_list,
        .hooker = CM_HOOKER_MESH_SSID
    },

    [CM_VLTREE_CLIENT_LIMIT] = {
        .key = "client_limit",
        .vltree = &cm_client_limit_vltree,
        .policy_list = &cm_client_limit_policy_list,
        .hooker = CM_HOOKER_CLIENT_LIMIT
    },

    [CM_VLTREE_TR069] = {
        .key = "tr069",
        .vltree = &cm_tr069_vltree,
        .policy_list = &cm_tr069_policy_list,
        .hooker = CM_HOOKER_TR069
    },

    [CM_VLTREE_USB_SHARE] = {
        .key = "usb_share",
        .vltree = &cm_usb_share_vltree,
        .policy_list = &cm_usb_share_policy_list,
        .hooker = CM_HOOKER_USB_SHARE
    },

    [CM_VLTREE_ALERT] = {
        .key = ALERT_CONFIG_SECTION_TYPE,
        .vltree = &cm_alert_vltree,
        .policy_list = &cm_alert_policy_list,
        .hooker = CM_HOOKER_ALERT
    },
    [CM_VLTREE_HOSTNAME] = {
        .key = "hostname",
        .vltree = &cm_hostname_vltree,
        .policy_list = &cm_hostname_policy_list,
        .hooker = CM_HOOKER_HOSTNAME
    },

    //Add for snmp start
    [CM_VLTREE_SNMP_CONFIG] = {
        .key = "snmpd",
        .vltree = &cm_snmp_config_vltree,
        .policy_list = &cm_snmp_config_policy_list,
        .hooker = CM_HOOKER_SNMP_CONFIG
    },
    [CM_VLTREE_SNMP_PORTS] = {
        .key = "snmpd_ports",
        .vltree = &cm_snmp_ports_vltree,
        .policy_list = &cm_snmp_ports_policy_list,
        .hooker = CM_HOOKER_SNMP_PORTS
    },
    [CM_VLTREE_SNMP_V3_AUTH] = {
        .key = "snmpv3_auth",
        .vltree = &cm_snmp_v3_auth_vltree,
        .policy_list = &cm_snmp_v3_auth_policy_list,
        .hooker = CM_HOOKER_SNMP_V3_AUTH
    },
    //Add for snmp end
#ifdef GWN77XX
    [CM_VLTREE_WIRED] = {
        .key = "wired",
        .vltree = &cm_wired_vltree,
        .policy_list = &cm_wired_policy_list,
        .hooker = CM_HOOKER_WIRED
    },

    [CM_VLTREE_GUEST] = {
        .key = "guest",
        .vltree = &cm_guest_vltree,
        .policy_list = &cm_guest_policy_list,
        .hooker = CM_HOOKER_GUEST
    },

    [CM_VLTREE_SCHEDULE_REBOOT] = {
        .key = "schedule_reboot",
        .vltree = &cm_schedule_reboot_vltree,
        .policy_list = &cm_schedule_reboot_policy_list,
        .hooker = CM_HOOKER_SCHEDULE_REBOOT
    },

    [CM_VLTREE_SECURITY] = {
        .key = "security",
        .vltree = &cm_security_vltree,
        .policy_list = &cm_security_policy_list,
        .hooker = CM_HOOKER_SECURITY
    },

    [CM_VLTREE_FLOW_SUPPRESSION] = {
        .key = "flow_suppression",
        .vltree = &cm_flow_suppression_vltree,
        .policy_list = &cm_flow_suppression_policy_list,
        .hooker = CM_HOOKER_FLOW_SUPPRESSION
    },
#endif
};
```

接着更新 vltree 的版本号

```c
vlist_update( vltree );

static inline void vlist_update(struct vlist_tree *tree)
{
	tree->version++;
}
```

然后加载节点配置

```c
cm_load_section( package, cm_vltree_info[section].key, section ); // key = basic
```

load之后执行的回调函数

```c
static const struct cm_hooker_policy cm_hp[__CM_HOOKER_MAX] ={
    [CM_HOOKER_WAN] = { .cb = cm_wan_hooker },
    [CM_HOOKER_WIRELESS] = { .cb = cm_wireless_hooker },
    [CM_HOOKER_LAN] = { .cb = cm_lan_hooker },
    [CM_HOOKER_UPGRADE_AUTO] = { .cb = cm_upgrade_auto_hooker },
    //Add for snmp start
    [CM_HOOKER_SNMP_CONFIG] = { .cb = cm_snmp_config_hooker, NULL },
    [CM_HOOKER_SNMP_PORTS] = { .cb = cm_snmp_ports_hooker, NULL },
    [CM_HOOKER_SNMP_V3_AUTH] = { .cb = cm_snmp_v3_auth_hooker, NULL },
    //Add for snmp end
#ifndef GWN77XX
    [CM_HOOKER_GUEST_SSID] = { .cb = cm_guest_ssid_hooker },
#endif
    [CM_HOOKER_ACCESS] = { .cb = cm_access_hooker },
    [CM_HOOKER_GLOBAL_ACCESS] = { .cb = cm_global_access_hooker },
    [CM_HOOKER_SCHEDULE_ACCESS] = { .cb = cm_schedule_access_hooker },
    [CM_HOOKER_BASIC_SYSTEM] = { .cb = cm_system_basic_hooker },
    [CM_HOOKER_CONTROLLER] = { .cb = cm_controller_hooker },
    [CM_HOOKER_AP] = { .cb = cm_ap_hooker },
    [CM_HOOKER_GENERAL] = { .cb = cm_general_hooker },
    [CM_HOOKER_VPN_SERVICE] = { .cb = cm_vpn_service_hooker },
    [CM_HOOKER_VPN_SPLIT] = { .cb = cm_vpn_split_hooker },
    [CM_HOOKER_UPNP] = { .cb = cm_upnp_hooker },
    [CM_HOOKER_DDNS] = { .cb = cm_ddns_hooker },
    [CM_HOOKER_STATIC_ROUTE_IPV4] = { .cb = cm_static_route_ipv4_hooker },
    [CM_HOOKER_MESH_SSID] = { .cb = cm_mesh_ssid_hooker },
    [CM_HOOKER_CLIENT_LIMIT] = { .cb = cm_client_limit_hooker },
    [CM_HOOKER_USB_SHARE] = {.cb = cm_usb_share_hooker },
    [CM_HOOKER_HOSTNAME] = { .cb = cm_hostname_hooker},
    [CM_HOOKER_ALERT] = {.cb = cm_alert_hooker},
    [CM_HOOKER_TR069] = {.cb = cm_tr069_hooker, NULL },
#ifdef GWN77XX
    [CM_HOOKER_WIRED] = { .cb = cm_wired_hooker },
    [CM_HOOKER_SCHEDULE_REBOOT] = { .cb = cm_schedule_reboot_hooker },
    [CM_HOOKER_SECURITY] = { .cb = cm_security_hooker},
    [CM_HOOKER_FLOW_SUPPRESSION] = { .cb = cm_flow_suppression_hooker},
#endif
};

static int cm_system_basic_hooker(
    struct blob_attr **new_config,
    int index,
    struct cm_vltree_extend *extend
)
{
    char temp[BUF_LEN_32] = { 0 };
    char data[BUF_LEN_64] = { 0 };
    struct blob_attr *cur_attr = new_config[index];
    int option = 0;
    int loop = 0;
    int action = extend->action;

    switch ( action ) {
        case VLTREE_ACTION_DEL:
            break;
        case VLTREE_ACTION_UPDATE:
        case VLTREE_ACTION_ADD:
            switch( index ) {
                case BASIC_TIME_ZONE:
                    strncpy( temp, util_blobmsg_get_string( cur_attr, "" ), sizeof( temp ) -1 );

                    for ( loop = 0; loop < timezone_num; loop++ ) {
                        if ( strncmp( temp, timezone_names[loop], strlen(timezone_names[loop]) -1 ) == 0 ) {
                            memcpy( data, timezone_values[loop], strlen(timezone_values[loop]) );
                            config_uci_set( "system.system.timezone", data, 0 );
                            break;
                        }
                    }
                    option |= BIT( CM_CFG_SYSTEM );
                    break;

                case BASIC_COUNTRY_CODE: {
                    struct cfparse_wifi_device *cfwdev;

                    strncpy( temp, util_blobmsg_get_string( cur_attr, "" ), sizeof( temp ) -1 );
                    config_uci_set( "grandstream.general.country", temp, 0 );
                    config_uci_set( "wireless.qcawifi.country", temp, 0 );

                    //Maybe some countries don't support 5g channels
                    cfwdev = util_get_vltree_node( &wireless_vltree, VLTREE_DEV, "wifi1" );
                    if( cfwdev ) {
                        config_set_radio_enable( temp, cfwdev->htmode );
                    }

                    option |= BIT( CM_CFG_GRANDSTREAM );
                    option |= BIT( CM_CFG_WIRELESS );
                }
                    break;

#ifndef GWN77XX
                case BASIC_LED_ON:
                    config_creat_no_exist_section( CF_CONFIG_NAME_GRANDSTREAM, "lights", "lights", &grandstream_led_vltree, VLTREE_GRANDSTREAM );
                    strncpy( temp, util_blobmsg_get_string( cur_attr, "" ), sizeof( temp ) -1 );
                    //led on
                    if ( temp[0] == '1' ) {
                        config_uci_set( "grandstream.lights.alwaysOff", "0", 0 );
                    }
                    //led off
                    if ( temp[0] == '0' ) {
                        config_uci_set( "grandstream.lights.alwaysOff", "1", 0 );
                    }
                    option |= BIT( CM_CFG_GRANDSTREAM );
                    break;
#else
               case BASIC_NTP_SERVER:
                       strncpy( temp, util_blobmsg_get_string(cur_attr, ""), sizeof(temp) -1 );

                       config_uci_del( "system.ntp.server", 0 );
                       if ( temp[0] != '\0' ) {
                           config_uci_add_list( "system.ntp.server", temp, 0 );
                       }

                       config_uci_del( "grandstream.general.ntp_server", 0 );
                       if ( temp[0] != '\0' ) {
                           config_uci_add_list( "grandstream.general.ntp_server", temp, 0 );
                       }

                       option |= BIT( CM_CFG_GRANDSTREAM );
                       option |= BIT( CM_CFG_SYSTEM );
                   break;

               case BASIC_DEV_PRODUCT_NAME:
                    break;
#endif
                default:
                        break;
            }
    }
    return option;
}
```

cm_system_basic_hooker 回调函数中会调用 config_uci_set 方法修改其他配置文件, 修改完成后返回修改的option, 全部修改完成后会自动调用
cfparse_load_file, 重新load刚刚修改的配置文件

如下日志显示更新 cfmanager 的 basic 节点的时区信息会修改 system 配置文件

```
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: sgreq_set_basic: path = cfmanager.basic.timeZone
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: config_uci_set: path:cfmanager.basic.timeZone   value:Pacific/Midway
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: config_commit: synchronize files :cfmanager
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: sgreq_set_basic: sgreq_set_basic CFMANAGER_CONFIG_NAME = cfmanager
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: cfparse_load_file: load cfmanager, section=9, force_load=0
Wed Jun  7 18:51:24 2023 daemon.warn cfmanager: cm_vltree_update: update cfmanager section  type 'basic', name 'basic'
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: config_uci_set: path:system.system.timezone   value:SST11
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: cm_load_cfmanager: Commit package system
Wed Jun  7 18:51:24 2023 daemon.debug cfmanager: cfparse_load_file: load system, section=0, force_load=0
Wed Jun  7 18:51:24 2023 daemon.warn cfmanager: cfparse_sys_vltree_update: update system section 'system'
```

最后遍历所有配置文件, 发现有修改就重新加载一遍, 过程和加载 cfmanager 配置一样

```c
    for( j = 1; j < __CM_CFG_MAX; j++ ) {
        if( cfg_option & BIT(j) ) {
            cfg_option &= ~BIT(j);
            cfmanager_log_message( L_DEBUG, "Commit package %s\n", cm_cfg_name[j].name );
            config_commit( cm_cfg_name[j].name, false );
            cfparse_load_file( cm_cfg_name[j].name, LOAD_ALL_SECTION, false );
        }
    }
```

接下来就是执行生效处理了，具体的生效处理在各自的xxx.c中执行，通过
cfparse_load_file函数进入到各自的生效处理流程，如果只需要重启相应的服务就能生效的只需要使用apply_add(配置文件名字)和apply_timer_start即可,如果需要做其它操作的则整体的处理流程和处理cfmanager一样

```c
cfparse_load_sys();

int cfparse_load_sys(
    void
)
{
    struct uci_element *e = NULL;
    struct uci_package *package = NULL;

    check_set_defvalue( CHECK_SYSTEM );

    package = cfparse_init_package( "system" );
    if ( !package ) {
        cfmanager_log_message( L_ERR, "load system package failed\n" );
        return -1;
    }

    vlist_update( &basic_system_vltree );

    uci_foreach_element( &package->sections, e ) {
        struct uci_section *s = uci_to_section( e );
        if( 0 == strcmp( s->type, "system" ) ) {
            cfparse_sys_uci_to_blob( s );
        }
    }

    vlist_flush( &basic_system_vltree );

    if( apply_get_reload_flag( CONFIG_TRACK_SYSTEM ) ) {
        apply_add( "system" );
        apply_flush_reload_flag( CONFIG_TRACK_SYSTEM );
        apply_timer_start();
    }

    return 0;
}
```

回到加载 cfmanager 配置文件这个方法

```c
cfparse_load_file( CFMANAGER_CONFIG_NAME, CM_VLTREE_BASIC, false );
```

后面的流程就是返回数据给 signaling_gateway 模块

```c
return_value:
    blob_buf_init( &reply, 0 );
    sgreq_return_must_info_to_sg( &reply, sg_params, error_state );
    ubus_send_reply( ctx, req, reply.head );
    blob_buf_free( &reply );
    return;
    
static void sgreq_return_must_info_to_sg(
    struct blob_buf *reply,
    struct sg_params *sg_params,
    int error_state
)
{
    char temp_buf[BUF_LEN_128];
    if( NULL == sg_params ) {
        return;
    }

    //blobmsg_add_string( reply, "hashID", sg_params->hashID );
    blobmsg_add_u32( reply, "id", sg_params->id );
    cfubus_wss_error_state_handle( error_state, temp_buf, sizeof( temp_buf ) );
    blobmsg_add_u32( reply, "retVal", error_state );
    blobmsg_add_string( reply, "retMsg", temp_buf );
}
```

很明显, 这里的信息和浏览器响应的信息一样。
